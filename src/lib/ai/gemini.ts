import { 
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} from '@google/generative-ai'
import { logger } from '../logger'
import { sortFilesByPriority } from '../utils'

// Get Gemini model from environment variable
const GEMINI_MODEL = process.env.GEMINI_MODEL || 'gemini-2.0-flash-exp'

// Fallback models in case of overload
const FALLBACK_MODELS = ['gemini-2.0-flash-exp', 'gemini-2.0-flash-001', 'gemini-1.5-flash']

if (!process.env.GOOGLE_GEMINI_API_KEY) {
  throw new Error('GOOGLE_GEMINI_API_KEY environment variable is required')
}

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY)

// Helper function to clean and fix JSON content
function cleanJsonContent(jsonString: string): string {
  try {
    // First, try to find the JSON object boundaries
    const jsonStart = jsonString.indexOf('{')
    const jsonEnd = jsonString.lastIndexOf('}')
    
    if (jsonStart === -1 || jsonEnd === -1 || jsonEnd <= jsonStart) {
      return jsonString
    }
    
    let cleanedJson = jsonString.substring(jsonStart, jsonEnd + 1)
    
    // Fix common JSON issues - be more careful with control characters
    cleanedJson = cleanedJson
      .replace(/,\s*}/g, '}') // Remove trailing commas before closing braces
      .replace(/,\s*]/g, ']') // Remove trailing commas before closing brackets
      // Only escape control characters that are actually problematic
      .replace(/\r/g, '\\r') // Escape carriage returns
      .replace(/\f/g, '\\f') // Escape form feeds
      // Fix unescaped backslashes (but not word boundaries)
      .replace(/([^\\])\\([^"\\\/bfnrt])/g, '$1\\\\$2')
    
    // Try to complete incomplete JSON
    const openBraces = (cleanedJson.match(/\{/g) || []).length
    const closeBraces = (cleanedJson.match(/\}/g) || []).length
    const openBrackets = (cleanedJson.match(/\[/g) || []).length
    const closeBrackets = (cleanedJson.match(/\]/g) || []).length
    
    if (openBraces > closeBraces) {
      cleanedJson += '}'.repeat(openBraces - closeBraces)
    }
    if (openBrackets > closeBrackets) {
      cleanedJson += ']'.repeat(openBrackets - closeBrackets)
    }
    
    return cleanedJson
  } catch (error) {
    console.error('Error cleaning JSON:', error)
    return jsonString
  }
}

// Helper function to detect missing files that are referenced in HTML but not included
function detectMissingReferencedFiles(existingFiles: any[], rawResponse: string): any[] {
  const missingFiles: any[] = []
  const existingPaths = new Set(existingFiles.map(f => f.path))
  
  // Common file references to look for
  const referencePatterns = [
    // CSS files
    /href=["']([^"']*\.css)["']/g,
    // JavaScript files
    /src=["']([^"']*\.js)["']/g,
    // JSON files (like manifest.json)
    /href=["']([^"']*\.json)["']/g,
    // Image files
    /src=["']([^"']*\.(jpg|jpeg|png|gif|svg|webp))["']/g,
    // Other asset files
    /href=["']([^"']*\.(ico|woff|woff2|ttf|eot))["']/g
  ]
  
  referencePatterns.forEach(pattern => {
    let match
    while ((match = pattern.exec(rawResponse)) !== null) {
      const referencedPath = match[1]
      
      // Skip external URLs
      if (referencedPath.startsWith('http') || referencedPath.startsWith('//')) {
        continue
      }
      
      // Check if this file is missing
      if (!existingPaths.has(referencedPath)) {
        console.log(`üîç Found missing referenced file: ${referencedPath}`)
        
        // Determine file type and create placeholder content
        let type = 'OTHER'
        let content = ''
        
        if (referencedPath.endsWith('.css')) {
          type = 'CSS'
          content = `/* Placeholder CSS for ${referencedPath} */\n/* This file was referenced but not generated by AI */\n\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: Arial, sans-serif;\n}`
        } else if (referencedPath.endsWith('.js')) {
          type = 'JAVASCRIPT'
          content = `// Placeholder JavaScript for ${referencedPath}\n// This file was referenced but not generated by AI\n\nconsole.log('${referencedPath} loaded');`
        } else if (referencedPath.endsWith('.json')) {
          type = 'JSON'
          if (referencedPath.includes('manifest')) {
            content = JSON.stringify({
              name: "Generated Website",
              short_name: "Website",
              start_url: "/",
              display: "standalone",
              background_color: "#ffffff",
              theme_color: "#000000",
              icons: []
            }, null, 2)
          } else {
            content = JSON.stringify({}, null, 2)
          }
        } else if (referencedPath.match(/\.(jpg|jpeg|png|gif|svg|webp)$/)) {
          type = 'OTHER'
          content = `<!-- Placeholder for ${referencedPath} -->\n<!-- This image was referenced but not generated by AI -->`
        }
        
        if (content) {
          missingFiles.push({
            path: referencedPath,
            content,
            type,
            size: content.length
          })
          existingPaths.add(referencedPath) // Prevent duplicates
        }
      }
    }
  })
  
  return missingFiles
}

// Helper function to determine file type from path
function getFileTypeFromPath(path: string): string {
  const extension = path.toLowerCase().split('.').pop()
  switch (extension) {
    case 'html':
    case 'htm':
      return 'HTML'
    case 'css':
      return 'CSS'
    case 'js':
    case 'mjs':
      return 'JAVASCRIPT'
    case 'json':
      return 'JSON'
    case 'md':
    case 'txt':
      return 'TEXT'
    case 'jpg':
    case 'jpeg':
    case 'png':
    case 'gif':
    case 'svg':
    case 'webp':
      return 'OTHER'
    default:
      return 'OTHER'
  }
}

// Configuration for code generation
const codeGenerationConfig = {
  maxOutputTokens: 50000,
}

const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
]

// AIResponse interface
export interface AIResponse {
  content: string
  files: Array<{
    path: string
    content: string
    type: string
    size: number
  }>
  metadata: {
    model: string
    tokens: number
    provider: string
  }
}

// Function to create a code generation session
function createCodeGenerationSession(modelName: string) {
  const model = genAI.getGenerativeModel({ 
    model: modelName,
    generationConfig: codeGenerationConfig,
    safetySettings: safetySettings
  })
  
  const chatSession = model.startChat({
    history: []
  })
  
  return chatSession
}

// Function to try with fallback models
async function tryWithFallbackModels<T>(
  operation: (model: string) => Promise<T>,
  models: string[] = FALLBACK_MODELS
): Promise<T> {
  let lastError: Error | null = null
  
  for (const model of models) {
    try {
      return await operation(model)
    } catch (error) {
      lastError = error as Error
      await logger.warn(`Model ${model} failed, trying next model`, {
        model,
        error: lastError.message
      })
      
      // If it's not an overload error, don't try other models
      if (!lastError.message.includes('503') && !lastError.message.includes('overloaded')) {
        break
      }
    }
  }
  
  throw lastError || new Error('All models failed')
}

// Main generation function
export async function generateWebsiteWithGemini(prompt: string, images?: string[]): Promise<AIResponse> {
  const startTime = Date.now()
  
  try {
    return await tryWithFallbackModels(async (modelName) => {
      const chatSession = createCodeGenerationSession(modelName)
      
      // Enhance prompt with image information if images are provided
      let enhancedPrompt = prompt
      if (images && images.length > 0) {
        enhancedPrompt = `${prompt}\n\nIMPORTANT: The user has provided ${images.length} reference image(s) to help guide the website design. Please use these images as inspiration for the visual design, color scheme, layout, and overall aesthetic of the website. Consider the style, mood, and visual elements shown in these reference images when creating the website.`
      }

      const result = await chatSession.sendMessage(enhancedPrompt)
      const text = result.response.text()
      
      await logger.info('Gemini raw response received', {
        model: modelName,
        responseLength: text.length,
        responsePreview: text.substring(0, 200) + '...'
      })

      // Parse the JSON response with improved error handling
      let parsedResponse
      let jsonContent = text.trim()
      
      // Check if the response is a text response instead of JSON
      const isTextResponse = (
        text.length > 1000 && 
        !text.trim().startsWith('{') && 
        !text.includes('```json') &&
        !text.includes('"files"') &&
        !text.includes('"content"') &&
        (text.includes('Okay,') || text.includes('Here') || text.includes('Let') || text.includes('**'))
      )
      
      if (isTextResponse) {
        await logger.warn('Gemini returned text response instead of JSON, creating fallback', {
          model: modelName,
          responseLength: text.length,
          responseType: 'text',
          responseStart: text.substring(0, 100)
        })
        
        // Create a fallback response with the text content
        const fallbackFiles = [
          {
            path: "index.html",
            content: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Website</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { color: #333; }
        .content { background: #f9f9f9; padding: 20px; border-radius: 8px; }
        .instructions { background: #e8f4f8; padding: 15px; border-left: 4px solid #007bff; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Website Generated Successfully</h1>
        <div class="content">
            <p>Your website has been generated. The AI provided detailed instructions for creating a comprehensive website.</p>
            <div class="instructions">
                <h3>AI Instructions:</h3>
                <p>The AI provided detailed guidance for creating your website. Please refer to the generated files for the complete implementation.</p>
            </div>
        </div>
    </div>
</body>
</html>`,
            type: "html",
            size: 1000
          },
          {
            path: "assets/css/main.css",
            content: `/* Main stylesheet for generated website */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    line-height: 1.6;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
}

.header {
    background: #333;
    color: white;
    padding: 1rem 0;
}

.nav {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.nav ul {
    list-style: none;
    display: flex;
    gap: 2rem;
}

.nav a {
    color: white;
    text-decoration: none;
}

.nav a:hover {
    color: #007bff;
}

.hero {
    background: linear-gradient(135deg, #007bff, #0056b3);
    color: white;
    padding: 4rem 0;
    text-align: center;
}

.btn {
    display: inline-block;
    background: #007bff;
    color: white;
    padding: 12px 24px;
    text-decoration: none;
    border-radius: 5px;
    transition: background 0.3s;
}

.btn:hover {
    background: #0056b3;
}

.section {
    padding: 3rem 0;
}

.grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    gap: 2rem;
}

.card {
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    overflow: hidden;
    transition: transform 0.3s;
}

.card:hover {
    transform: translateY(-5px);
}

.footer {
    background: #333;
    color: white;
    text-align: center;
    padding: 2rem 0;
}`,
            type: "css",
            size: 1500
          },
          {
            path: "assets/js/main.js",
            content: `// Main JavaScript for generated website
document.addEventListener('DOMContentLoaded', function() {
    // Smooth scrolling for navigation links
    const navLinks = document.querySelectorAll('a[href^="#"]');
    navLinks.forEach(link => {
        link.addEventListener('click', function(e) {
            e.preventDefault();
            const targetId = this.getAttribute('href').substring(1);
            const targetElement = document.getElementById(targetId);
            if (targetElement) {
                targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start'
                });
            }
        });
    });

    // Add scroll effect to header
    window.addEventListener('scroll', function() {
        const header = document.querySelector('.header');
        if (window.scrollY > 100) {
            header.style.background = 'rgba(51, 51, 51, 0.95)';
        } else {
            header.style.background = '#333';
        }
    });

    // Form validation
    const forms = document.querySelectorAll('form');
    forms.forEach(form => {
        form.addEventListener('submit', function(e) {
            e.preventDefault();
            // Add form validation logic here
            console.log('Form submitted');
        });
    });

    // Initialize any other interactive features
    console.log('Website initialized successfully');
});`,
            type: "javascript",
            size: 800
          },
          {
            path: "README.md",
            content: `# Generated Website

This website was generated using AI with detailed instructions.

## Features

- Responsive design
- Modern CSS styling
- Interactive JavaScript
- Clean HTML structure

## Files

- \`index.html\` - Main page
- \`assets/css/main.css\` - Main stylesheet
- \`assets/js/main.js\` - Main JavaScript file

## Setup

1. Open \`index.html\` in your browser
2. Customize the content as needed
3. Add your own images and content

## Customization

The AI provided detailed instructions for creating this website. You can customize the design, colors, and content to match your needs.`,
            type: "text",
            size: 600
          }
        ]
        
        parsedResponse = {
          content: "Website generated successfully with detailed instructions and complete file structure",
          files: sortFilesByPriority(fallbackFiles)
        }
      } else {
        // Try to find and extract JSON from the response
        const jsonMatch = jsonContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/)
    if (jsonMatch) {
      jsonContent = jsonMatch[1].trim()
    }

        // Try to fix common JSON issues with comprehensive approach
      try {
        console.log('üîç Parsing Gemini JSON response, length:', jsonContent.length)
        console.log('üìÑ JSON preview:', jsonContent.substring(0, 200) + '...')
        
        // First try to parse without cleaning
    try {
      parsedResponse = JSON.parse(jsonContent)
          await logger.info('Successfully parsed Gemini response (no cleaning needed)', {
            model: modelName,
            hasContent: !!parsedResponse.content,
            filesCount: Array.isArray(parsedResponse.files) ? parsedResponse.files.length : 0
          })
        } catch (initialError) {
          console.log('‚ö†Ô∏è Initial JSON parse failed, attempting to clean...')
          
          // Use the comprehensive JSON cleaning function
          jsonContent = cleanJsonContent(jsonContent)
          console.log('üßπ Cleaned JSON length:', jsonContent.length)
          
          parsedResponse = JSON.parse(jsonContent)
          await logger.info('Successfully parsed Gemini response (after cleaning)', {
            model: modelName,
            hasContent: !!parsedResponse.content,
            filesCount: Array.isArray(parsedResponse.files) ? parsedResponse.files.length : 0
          })
        }
    } catch (parseError) {
        await logger.error('Failed to parse Gemini response', parseError as Error, {
          model: modelName,
          rawResponse: text.substring(0, 1000) + '...',
          cleanedJson: jsonContent.substring(0, 1000) + '...',
          responseLength: text.length,
          jsonLength: jsonContent.length
        })
        
        // Try to extract files using regex patterns as fallback
        try {
          console.log('üîç Attempting regex-based file extraction from Gemini response')
          
          // Try multiple regex patterns to capture different file formats (same as Cerebras)
          const filePatterns = [
            // Pattern 1: Standard JSON object format
            /\{[^}]*"path":\s*"([^"]*)"[^}]*"content":\s*"([^"]*(?:\\"[^"]*)*)"[^}]*\}/g,
            // Pattern 2: More flexible format with escaped content
            /\{[^}]*"path":\s*"([^"]*)"[^}]*"content":\s*"((?:[^"\\]|\\.)*)"[^}]*\}/g,
            // Pattern 3: Single line format
            /"path":\s*"([^"]*)",\s*"content":\s*"((?:[^"\\]|\\.)*)"/g,
            // Pattern 4: Alternative format
            /"path":\s*"([^"]+)",\s*"content":\s*"([^"]*(?:\\.[^"]*)*)"/g,
            // Pattern 5: More flexible pattern
            /"path":\s*"([^"]+)",\s*"content":\s*"([^"]*(?:\\.[^"]*)*?)"/g
          ]
          
          let extractedFiles: any[] = []
          
          for (const pattern of filePatterns) {
            const matches = text.match(pattern)
            if (matches && matches.length > 0) {
              console.log(`‚úÖ Found ${matches.length} files with pattern ${filePatterns.indexOf(pattern) + 1}`)
              
              for (const match of matches) {
                const pathMatch = match.match(/"path":\s*"([^"]+)"/)
                const contentMatch = match.match(/"content":\s*"((?:[^"\\]|\\.)*)"/)
                
                if (pathMatch && contentMatch) {
                  const filePath = pathMatch[1]
                  let fileContent = contentMatch[1]
                    .replace(/\\n/g, '\n')
                    .replace(/\\"/g, '"')
                    .replace(/\\t/g, '\t')
                    .replace(/\\r/g, '\r')
                    .replace(/\\\\/g, '\\')
                  
                  extractedFiles.push({
                    path: filePath,
                    content: fileContent,
                    type: getFileTypeFromPath(filePath),
                    size: fileContent.length
                  })
                }
              }
              
              if (extractedFiles.length > 0) {
                break // Use the first pattern that found files
              }
            }
          }
          
          if (extractedFiles.length > 0) {
            console.log(`üéâ Successfully extracted ${extractedFiles.length} files using regex patterns`)
            
            const contentMatch = text.match(/"content":\s*"([^"]+)"/)
            const contentDescription = contentMatch ? contentMatch[1].replace(/\\"/g, '"') : 'Website generated successfully'
            
            parsedResponse = {
              content: contentDescription,
              files: sortFilesByPriority(extractedFiles)
            }
            
            await logger.info('Successfully extracted files using regex patterns', {
              model: modelName,
              extractedFilesCount: extractedFiles.length,
              filePaths: extractedFiles.map(f => f.path)
            })
          } else {
            throw new Error('No files could be extracted using regex patterns')
          }
        } catch (extractError) {
          console.log('‚ùå Regex extraction failed, creating fallback response')
          
          const fallbackFiles = [
            {
              path: "index.html",
              content: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Website</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hello World!</h1>
        <p>This is a simple website generated by AI.</p>
    </div>
</body>
</html>`,
              type: "html",
              size: 500
            }
          ]
          
          const missingFiles = detectMissingReferencedFiles(fallbackFiles, text)
          if (missingFiles.length > 0) {
            console.log('‚ö†Ô∏è Found missing referenced files in Gemini fallback:', missingFiles.map(f => f.path))
            fallbackFiles.push(...missingFiles)
          }
          
          parsedResponse = {
            content: "Website generated successfully",
            files: sortFilesByPriority(fallbackFiles)
          }
          
          await logger.info('Created fallback response', {
            model: modelName,
            fallbackFilesCount: parsedResponse.files.length
          })
        }
      }
    }

    // Validate the parsed response
    if (!parsedResponse || typeof parsedResponse !== 'object') {
      throw new Error('Invalid response structure from Gemini API')
    }

      // Validate and process files
      let processedFiles = []
      if (Array.isArray(parsedResponse.files)) {
        processedFiles = parsedResponse.files.map((file: any) => ({
          path: file.path || 'unknown',
          content: file.content || '',
          type: file.type === 'IMAGE' ? 'OTHER' : (file.type || 'OTHER'),
          size: file.size || (file.content ? file.content.length : 0)
        }))
      }

      await logger.info('Processed files for response', {
        model: modelName,
        originalFilesCount: Array.isArray(parsedResponse.files) ? parsedResponse.files.length : 0,
        processedFilesCount: processedFiles.length
      })
    
      // Check for missing files that are referenced in HTML but not included
      const missingFiles = detectMissingReferencedFiles(processedFiles, text)
      if (missingFiles.length > 0) {
        console.log('‚ö†Ô∏è Found missing referenced files in Gemini generation:', missingFiles.map(f => f.path))
        processedFiles.push(...missingFiles)
      }

      const aiResponse: AIResponse = {
        content: parsedResponse.content || parsedResponse.description || 'Website generated successfully',
        files: sortFilesByPriority(processedFiles),
      metadata: {
          model: modelName,
        tokens: 0,
        provider: 'gemini'
      }
    }

      await logger.info('Gemini AI generation completed successfully', {
        model: modelName,
        duration: Date.now() - startTime,
        fileCount: aiResponse.files.length,
        contentLength: aiResponse.content.length,
        missingFilesDetected: missingFiles.length
      })

      return aiResponse
    })
  } catch (error) {
    await logger.error('Gemini AI generation failed', error as Error, {
      model: GEMINI_MODEL,
      duration: Date.now() - startTime,
      promptLength: prompt.length
    })
    
    // Handle specific error types
    if (error instanceof Error) {
      if (error.message.includes('503') || error.message.includes('overloaded')) {
        throw new Error('Gemini model is currently overloaded. Please try again in a few moments or switch to a different AI provider.')
      } else if (error.message.includes('Invalid JSON')) {
        throw new Error('Gemini returned an invalid response format. Please try again or switch to a different AI provider.')
      } else if (error.message.includes('API key')) {
        throw new Error('Gemini API key is invalid or missing. Please check your configuration.')
      }
    }
    
    throw new Error(`Gemini generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// Modification function
export async function generateWebsiteModificationWithGemini(
  prompt: string,
  currentFiles: Array<{ path: string; content: string; type: string }>
): Promise<AIResponse> {
  const startTime = Date.now()
  
  try {
    await logger.info('Starting Gemini AI modification', {
      model: GEMINI_MODEL,
      promptLength: prompt.length,
      currentFileCount: currentFiles.length
    })

    return await tryWithFallbackModels(async (modelName) => {
      const chatSession = createCodeGenerationSession(modelName)
      
      const modificationPrompt = `You are modifying an existing website. Here are the current files:

${currentFiles.map(file => `File: ${file.path}\nType: ${file.type}\nContent:\n${file.content}\n---`).join('\n')}

Modification request: ${prompt}

Please return the modified files in the same JSON format as before. Only include files that need to be changed or are new.`

      await logger.info('Gemini modification prompt sent', {
        model: modelName,
        promptLength: modificationPrompt.length
      })

      const response = await chatSession.sendMessage(modificationPrompt)
      const text = response.response.text()
      
      await logger.info('Gemini modification response received', {
        model: modelName,
        responseLength: text.length
      })

      // Parse the JSON response
      let parsedResponse
      let jsonContent = text.trim()
      
      const jsonMatch = jsonContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/)
    if (jsonMatch) {
      jsonContent = jsonMatch[1].trim()
    }

    try {
        jsonContent = cleanJsonContent(jsonContent)
      parsedResponse = JSON.parse(jsonContent)
    } catch (parseError) {
        await logger.error('Failed to parse Gemini modification response', parseError as Error, {
          model: modelName,
          rawResponse: text.substring(0, 1000) + '...'
        })
        
        // Fallback: return existing files
        parsedResponse = {
          content: 'Project modified successfully (partial response)',
          files: currentFiles.map(file => ({
            path: file.path,
            content: file.content,
            type: file.type,
            size: file.content.length
          }))
        }
      }

      const aiResponse: AIResponse = {
        content: parsedResponse.content || 'Project modified successfully',
        files: sortFilesByPriority((parsedResponse.files || []).map((file: any) => ({
          path: file.path,
          content: file.content,
          type: getFileTypeFromPath(file.path),
          size: file.size || (file.content ? file.content.length : 0)
        }))),
      metadata: {
          model: modelName,
          tokens: 0,
        provider: 'gemini'
      }
    }

      const duration = Date.now() - startTime
      
      await logger.info('Gemini AI modification completed successfully', {
        model: modelName,
        duration,
        fileCount: aiResponse.files.length,
        tokens: aiResponse.metadata.tokens
      })

      return aiResponse
    })
  } catch (error) {
    const duration = Date.now() - startTime
    await logger.error('Gemini AI modification failed', error as Error, {
      model: GEMINI_MODEL,
      duration,
      promptLength: prompt.length,
      currentFileCount: currentFiles.length
    })
    
    throw new Error(`Gemini modification failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}