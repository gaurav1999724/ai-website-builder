import { 
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} from '@google/generative-ai'
import { logger } from '../logger'
import { sortFilesByPriority } from '../utils'

// Get Gemini model from environment variable
const GEMINI_MODEL = process.env.GEMINI_MODEL || 'gemini-2.0-flash-exp'

// Fallback models in case of overload
const FALLBACK_MODELS = ['gemini-2.0-flash-exp', 'gemini-2.0-flash-001', 'gemini-1.5-flash']

if (!process.env.GOOGLE_GEMINI_API_KEY) {
  throw new Error('GOOGLE_GEMINI_API_KEY environment variable is required')
}

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_GEMINI_API_KEY)

// Helper function to clean and fix JSON content
function cleanJsonContent(jsonString: string): string {
  try {
    // First, try to find the JSON object boundaries
    const jsonStart = jsonString.indexOf('{')
    const jsonEnd = jsonString.lastIndexOf('}')
    
    if (jsonStart === -1 || jsonEnd === -1 || jsonEnd <= jsonStart) {
      return jsonString
    }
    
    let cleanedJson = jsonString.substring(jsonStart, jsonEnd + 1)
    
    // Fix common JSON issues
    cleanedJson = cleanedJson
      .replace(/,\s*}/g, '}') // Remove trailing commas before closing braces
      .replace(/,\s*]/g, ']') // Remove trailing commas before closing brackets
      // Fix control characters that cause JSON parsing errors
      .replace(/\n/g, '\\n') // Escape unescaped newlines
      .replace(/\r/g, '\\r') // Escape unescaped carriage returns
      .replace(/\t/g, '\\t') // Escape unescaped tabs
      .replace(/\b/g, '\\b') // Escape backspaces
      .replace(/\f/g, '\\f') // Escape form feeds
      // Fix unescaped backslashes
      .replace(/([^\\])\\([^"\\\/bfnrt])/g, '$1\\\\$2')
    
    // Try to complete incomplete JSON
    const openBraces = (cleanedJson.match(/\{/g) || []).length
    const closeBraces = (cleanedJson.match(/\}/g) || []).length
    const openBrackets = (cleanedJson.match(/\[/g) || []).length
    const closeBrackets = (cleanedJson.match(/\]/g) || []).length
    
    if (openBraces > closeBraces) {
      cleanedJson += '}'.repeat(openBraces - closeBraces)
    }
    if (openBrackets > closeBrackets) {
      cleanedJson += ']'.repeat(openBrackets - closeBrackets)
    }
    
    return cleanedJson
  } catch (error) {
    console.error('Error cleaning JSON:', error)
    return jsonString
  }
}

// Helper function to detect missing files that are referenced in HTML but not included
function detectMissingReferencedFiles(existingFiles: any[], rawResponse: string): any[] {
  const missingFiles: any[] = []
  const existingPaths = new Set(existingFiles.map(f => f.path))
  
  // Common file references to look for
  const referencePatterns = [
    // CSS files
    /href=["']([^"']*\.css)["']/g,
    // JavaScript files
    /src=["']([^"']*\.js)["']/g,
    // JSON files (like manifest.json)
    /href=["']([^"']*\.json)["']/g,
    // Image files
    /src=["']([^"']*\.(jpg|jpeg|png|gif|svg|webp))["']/g,
    // Other asset files
    /href=["']([^"']*\.(ico|woff|woff2|ttf|eot))["']/g
  ]
  
  referencePatterns.forEach(pattern => {
    let match
    while ((match = pattern.exec(rawResponse)) !== null) {
      const referencedPath = match[1]
      
      // Skip external URLs
      if (referencedPath.startsWith('http') || referencedPath.startsWith('//')) {
        continue
      }
      
      // Check if this file is missing
      if (!existingPaths.has(referencedPath)) {
        console.log(`üîç Found missing referenced file: ${referencedPath}`)
        
        // Determine file type and create placeholder content
        let type = 'OTHER'
        let content = ''
        
        if (referencedPath.endsWith('.css')) {
          type = 'CSS'
          content = `/* Placeholder CSS for ${referencedPath} */\n/* This file was referenced but not generated by AI */\n\nbody {\n  margin: 0;\n  padding: 0;\n  font-family: Arial, sans-serif;\n}`
        } else if (referencedPath.endsWith('.js')) {
          type = 'JAVASCRIPT'
          content = `// Placeholder JavaScript for ${referencedPath}\n// This file was referenced but not generated by AI\n\nconsole.log('${referencedPath} loaded');`
        } else if (referencedPath.endsWith('.json')) {
          type = 'JSON'
          if (referencedPath.includes('manifest')) {
            content = JSON.stringify({
              name: "Generated Website",
              short_name: "Website",
              start_url: "/",
              display: "standalone",
              background_color: "#ffffff",
              theme_color: "#000000",
              icons: []
            }, null, 2)
          } else {
            content = JSON.stringify({}, null, 2)
          }
        } else if (referencedPath.match(/\.(jpg|jpeg|png|gif|svg|webp)$/)) {
          type = 'OTHER'
          content = `<!-- Placeholder for ${referencedPath} -->\n<!-- This image was referenced but not generated by AI -->`
        }
        
        if (content) {
          missingFiles.push({
            path: referencedPath,
            content,
            type,
            size: content.length
          })
          existingPaths.add(referencedPath) // Prevent duplicates
        }
      }
    }
  })
  
  return missingFiles
}

// Helper function to determine file type from path
function getFileTypeFromPath(path: string): string {
  const extension = path.toLowerCase().split('.').pop()
  switch (extension) {
    case 'html':
    case 'htm':
      return 'HTML'
    case 'css':
      return 'CSS'
    case 'js':
    case 'mjs':
      return 'JAVASCRIPT'
    case 'json':
      return 'JSON'
    case 'md':
    case 'txt':
      return 'TEXT'
    case 'jpg':
    case 'jpeg':
    case 'png':
    case 'gif':
    case 'svg':
    case 'webp':
      return 'OTHER'
    default:
      return 'OTHER'
  }
}

// Configuration objects for different use cases
const generationConfig = {
  temperature: 1,
  topP: 0.95,
  topK: 40,
  maxOutputTokens: 8192,
}

const codeGenerationConfig = {
  temperature: 0.7,
  topP: 0.9,
  topK: 32,
  maxOutputTokens: 8192,
}

const enhancePromptConfig = {
  temperature: 0.3,
  topP: 0.8,
  topK: 20,
  maxOutputTokens: 1024,
}

const safetySettings = [
  {
    category: HarmCategory.HARM_CATEGORY_HARASSMENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_HATE_SPEECH,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
  {
    category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT,
    threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
  },
]

// AIResponse interface
export interface AIResponse {
  content: string
  files: Array<{
    path: string
    content: string
    type: string
    size: number
  }>
  metadata: {
    model: string
    tokens: number
    provider: string
  }
}

// Function to create a code generation session
function createCodeGenerationSession(modelName: string) {
  const model = genAI.getGenerativeModel({ 
    model: modelName,
    generationConfig: codeGenerationConfig,
    safetySettings: safetySettings
  })
  
  const chatSession = model.startChat({
    history: [
      {
        role: "user",
        parts: [{ text: "You are an EXPERT FULL-STACK WEB DEVELOPER with 10+ years of experience. You specialize in creating modern, responsive, and high-quality websites using HTML5, CSS3, JavaScript (ES6+), and modern web technologies.\n\nCRITICAL REQUIREMENTS - ADVANCED PROJECT GENERATION:\n\n1. **MULTIPLE FILES**: Always generate 8-15+ files including:\n   - Multiple HTML pages (index.html, about.html, services.html, contact.html, etc.)\n   - CSS files (main.css, components.css, responsive.css)\n   - JavaScript files (main.js, components.js, utils.js)\n   - Additional assets (README.md, package.json, manifest.json)\n\n2. **ADVANCED COMPONENTS**: Include modern web components like:\n   - Responsive navigation with mobile menu\n   - Interactive forms with validation\n   - Image galleries or carousels\n   - Modal dialogs\n   - Animations and transitions\n   - API integrations or data fetching\n\n3. **MODERN ARCHITECTURE**: Use:\n   - Semantic HTML5 elements\n   - CSS Grid and Flexbox for layouts\n   - Modern JavaScript (ES6+, async/await, modules)\n   - Responsive design principles\n   - Accessibility best practices (ARIA labels, keyboard navigation)\n\n4. **ENTERPRISE-LEVEL CODE QUALITY**:\n   - Clean, well-commented code\n   - Consistent naming conventions\n   - Proper error handling\n   - Performance optimizations\n   - Cross-browser compatibility\n\n5. **DETAILED FILE STRUCTURE**:\n   - index.html (main landing page)\n   - about.html, services.html, contact.html (additional pages)\n   - assets/css/main.css (primary styles)\n   - assets/css/components.css (component-specific styles)\n   - assets/js/main.js (main functionality)\n   - assets/js/components.js (reusable components)\n   - README.md (project documentation)\n   - package.json (dependencies and scripts)\n\n6. **ADVANCED DESIGN FEATURES**:\n   - Modern color schemes and typography\n   - Smooth animations and micro-interactions\n   - Professional layouts and spacing\n   - High-quality visual hierarchy\n   - Mobile-first responsive design\n\n7. **PERFORMANCE & OPTIMIZATION**:\n   - Optimized images and assets\n   - Efficient CSS and JavaScript\n   - Fast loading times\n   - SEO-friendly structure\n\n8. **ADVANCED FUNCTIONALITY**:\n   - Interactive elements\n   - Form validation and submission\n   - Dynamic content loading\n   - User experience enhancements\n\n9. **RESPONSIVE & ACCESSIBLE**:\n   - Mobile-first design approach\n   - Cross-device compatibility\n   - WCAG accessibility guidelines\n   - Keyboard navigation support\n\n10. **CODE QUALITY STANDARDS**:\n    - Clean, maintainable code\n    - Proper documentation\n    - Consistent formatting\n    - Best practices implementation\n\nüñºÔ∏è IMAGE REQUIREMENTS:\n- ALWAYS use external image URLs for placeholder images\n- Use Picsum (https://picsum.photos/) for generic images\n- Use Unsplash (https://unsplash.com/) for high-quality photos\n- For food websites: https://images.unsplash.com/photo-1565299624946-b28f40a0ca4b\n- For business websites: https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d\n- For tech websites: https://images.unsplash.com/photo-1518709268805-4e9042af2176\n- For portfolio websites: https://images.unsplash.com/photo-1507003211169-0a1dd7228f2d\n- NEVER use local image paths like 'assets/images/chef.jpg' - always use full URLs\n\nIMPORTANT: Return ONLY valid JSON in this exact format:\n{\n  \"content\": \"Brief description of the generated website\",\n  \"files\": [\n    {\n      \"path\": \"index.html\",\n      \"content\": \"Complete HTML content here\",\n      \"type\": \"HTML\"\n    },\n    {\n      \"path\": \"assets/css/main.css\",\n      \"content\": \"Complete CSS content here\",\n      \"type\": \"CSS\"\n    },\n    {\n      \"path\": \"assets/js/main.js\",\n      \"content\": \"Complete JavaScript content here\",\n      \"type\": \"JAVASCRIPT\"\n    }\n  ]\n}\n\nCRITICAL: Ensure the JSON is properly closed and all strings are properly escaped. Do not include any text outside the JSON structure." }]
      },
      {
        role: "model",
        parts: [{ text: "I understand. I am an EXPERT FULL-STACK WEB DEVELOPER and I will create advanced, multi-file website projects with modern architecture, enterprise-level code quality, and comprehensive functionality. I will always return valid JSON with 8-15+ files including multiple HTML pages, CSS files, JavaScript files, and additional assets. I will use external image URLs and ensure all code follows best practices for responsive design, accessibility, and performance optimization." }]
      }
    ]
  })
  
  return chatSession
}

// Function to try with fallback models
async function tryWithFallbackModels<T>(
  operation: (model: string) => Promise<T>,
  models: string[] = FALLBACK_MODELS
): Promise<T> {
  let lastError: Error | null = null
  
  for (const model of models) {
    try {
      return await operation(model)
    } catch (error) {
      lastError = error as Error
      await logger.warn(`Model ${model} failed, trying next model`, {
        model,
        error: lastError.message
      })
      
      // If it's not an overload error, don't try other models
      if (!lastError.message.includes('503') && !lastError.message.includes('overloaded')) {
        break
      }
    }
  }
  
  throw lastError || new Error('All models failed')
}

// Main generation function
export async function generateWebsiteWithGemini(prompt: string, images?: string[]): Promise<AIResponse> {
  const startTime = Date.now()
  
  try {
    await logger.info('Starting Gemini AI generation', {
      model: GEMINI_MODEL,
      promptLength: prompt.length,
      hasImages: !!images?.length
    })

    return await tryWithFallbackModels(async (modelName) => {
      const chatSession = createCodeGenerationSession(modelName)
      
      // Enhance prompt with image information if images are provided
      let enhancedPrompt = prompt
      if (images && images.length > 0) {
        enhancedPrompt = `${prompt}\n\nIMPORTANT: The user has provided ${images.length} reference image(s) to help guide the website design. Please use these images as inspiration for the visual design, color scheme, layout, and overall aesthetic of the website. Consider the style, mood, and visual elements shown in these reference images when creating the website.`
      }

      const result = await chatSession.sendMessage(enhancedPrompt)
      const text = result.response.text()
      
      await logger.info('Gemini raw response received', {
        model: modelName,
        responseLength: text.length,
        responsePreview: text.substring(0, 200) + '...'
      })

      // Parse the JSON response with improved error handling
      let parsedResponse
      let jsonContent = text.trim()
      
      // Try to find and extract JSON from the response
      const jsonMatch = jsonContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/)
      if (jsonMatch) {
        jsonContent = jsonMatch[1].trim()
      }
      
      // Try to fix common JSON issues with comprehensive approach
      try {
        console.log('üîç Parsing Gemini JSON response, length:', jsonContent.length)
        
        // Use the comprehensive JSON cleaning function
        jsonContent = cleanJsonContent(jsonContent)
        console.log('üßπ Cleaned JSON length:', jsonContent.length)
        
        parsedResponse = JSON.parse(jsonContent)
        await logger.info('Successfully parsed Gemini response', {
          model: modelName,
          hasContent: !!parsedResponse.content,
          filesCount: Array.isArray(parsedResponse.files) ? parsedResponse.files.length : 0
        })
      } catch (parseError) {
        await logger.error('Failed to parse Gemini response', parseError as Error, {
          model: modelName,
          rawResponse: text.substring(0, 1000) + '...',
          cleanedJson: jsonContent.substring(0, 1000) + '...',
          responseLength: text.length,
          jsonLength: jsonContent.length
        })
        
        // Try to extract files using regex patterns as fallback
        try {
          console.log('üîç Attempting regex-based file extraction from Gemini response')
          
          const filePatterns = [
            /"path":\s*"([^"]+)",\s*"content":\s*"((?:[^"\\]|\\.)*)"/g,
            /"path":\s*"([^"]+)",\s*"content":\s*"([^"]*(?:\\.[^"]*)*)"/g,
            /"path":\s*"([^"]+)",\s*"content":\s*"([^"]*(?:\\.[^"]*)*?)"/g
          ]
          
          let extractedFiles: any[] = []
          
          for (const pattern of filePatterns) {
            const matches = text.match(pattern)
            if (matches && matches.length > 0) {
              console.log(`‚úÖ Found ${matches.length} files with pattern`)
              
              for (const match of matches) {
                const pathMatch = match.match(/"path":\s*"([^"]+)"/)
                const contentMatch = match.match(/"content":\s*"((?:[^"\\]|\\.)*)"/)
                
                if (pathMatch && contentMatch) {
                  const filePath = pathMatch[1]
                  let fileContent = contentMatch[1]
                    .replace(/\\n/g, '\n')
                    .replace(/\\"/g, '"')
                    .replace(/\\t/g, '\t')
                    .replace(/\\r/g, '\r')
                    .replace(/\\\\/g, '\\')
                  
                  extractedFiles.push({
                    path: filePath,
                    content: fileContent,
                    type: getFileTypeFromPath(filePath),
                    size: fileContent.length
                  })
                }
              }
              
              if (extractedFiles.length > 0) {
                break
              }
            }
          }
          
          if (extractedFiles.length > 0) {
            console.log(`üéâ Successfully extracted ${extractedFiles.length} files using regex patterns`)
            
            const contentMatch = text.match(/"content":\s*"([^"]+)"/)
            const contentDescription = contentMatch ? contentMatch[1].replace(/\\"/g, '"') : 'Website generated successfully'
            
            parsedResponse = {
              content: contentDescription,
              files: sortFilesByPriority(extractedFiles)
            }
            
            await logger.info('Successfully extracted files using regex patterns', {
              model: modelName,
              extractedFilesCount: extractedFiles.length,
              filePaths: extractedFiles.map(f => f.path)
            })
          } else {
            throw new Error('No files could be extracted using regex patterns')
          }
        } catch (extractError) {
          console.log('‚ùå Regex extraction failed, creating fallback response')
          
          const fallbackFiles = [
            {
              path: "index.html",
              content: `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generated Website</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .container { max-width: 800px; margin: 0 auto; }
        h1 { color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Hello World!</h1>
        <p>This is a simple website generated by AI.</p>
    </div>
</body>
</html>`,
              type: "html",
              size: 500
            }
          ]
          
          const missingFiles = detectMissingReferencedFiles(fallbackFiles, text)
          if (missingFiles.length > 0) {
            console.log('‚ö†Ô∏è Found missing referenced files in Gemini fallback:', missingFiles.map(f => f.path))
            fallbackFiles.push(...missingFiles)
          }
          
          parsedResponse = {
            content: "Website generated successfully",
            files: sortFilesByPriority(fallbackFiles)
          }
          
          await logger.info('Created fallback response', {
            model: modelName,
            fallbackFilesCount: parsedResponse.files.length
          })
        }
      }

      // Validate the parsed response
      if (!parsedResponse || typeof parsedResponse !== 'object') {
        throw new Error('Invalid response structure from Gemini API')
      }
      
      // Validate and process files
      let processedFiles = []
      if (Array.isArray(parsedResponse.files)) {
        processedFiles = parsedResponse.files.map((file: any) => ({
          path: file.path || 'unknown',
          content: file.content || '',
          type: file.type === 'IMAGE' ? 'OTHER' : (file.type || 'OTHER'),
          size: file.size || (file.content ? file.content.length : 0)
        }))
      }

      await logger.info('Processed files for response', {
        model: modelName,
        originalFilesCount: Array.isArray(parsedResponse.files) ? parsedResponse.files.length : 0,
        processedFilesCount: processedFiles.length
      })
    
      // Check for missing files that are referenced in HTML but not included
      const missingFiles = detectMissingReferencedFiles(processedFiles, text)
      if (missingFiles.length > 0) {
        console.log('‚ö†Ô∏è Found missing referenced files in Gemini generation:', missingFiles.map(f => f.path))
        processedFiles.push(...missingFiles)
      }

      const aiResponse: AIResponse = {
        content: parsedResponse.content || parsedResponse.description || 'Website generated successfully',
        files: sortFilesByPriority(processedFiles),
        metadata: {
          model: modelName,
          tokens: 0,
          provider: 'gemini'
        }
      }

      await logger.info('Gemini AI generation completed successfully', {
        model: modelName,
        duration: Date.now() - startTime,
        fileCount: aiResponse.files.length,
        contentLength: aiResponse.content.length,
        missingFilesDetected: missingFiles.length
      })

      return aiResponse
    })
  } catch (error) {
    await logger.error('Gemini AI generation failed', error as Error, {
      model: GEMINI_MODEL,
      duration: Date.now() - startTime,
      promptLength: prompt.length
    })
    
    // Handle specific error types
    if (error instanceof Error) {
      if (error.message.includes('503') || error.message.includes('overloaded')) {
        throw new Error('Gemini model is currently overloaded. Please try again in a few moments or switch to a different AI provider.')
      } else if (error.message.includes('Invalid JSON')) {
        throw new Error('Gemini returned an invalid response format. Please try again or switch to a different AI provider.')
      } else if (error.message.includes('API key')) {
        throw new Error('Gemini API key is invalid or missing. Please check your configuration.')
      }
    }
    
    throw new Error(`Gemini generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}

// Modification function
export async function generateWebsiteModificationWithGemini(
  prompt: string,
  currentFiles: Array<{ path: string; content: string; type: string }>
): Promise<AIResponse> {
  const startTime = Date.now()
  
  try {
    await logger.info('Starting Gemini AI modification', {
      model: GEMINI_MODEL,
      promptLength: prompt.length,
      currentFileCount: currentFiles.length
    })

    return await tryWithFallbackModels(async (modelName) => {
      const chatSession = createCodeGenerationSession(modelName)
      
      const modificationPrompt = `You are modifying an existing website. Here are the current files:

${currentFiles.map(file => `File: ${file.path}\nType: ${file.type}\nContent:\n${file.content}\n---`).join('\n')}

Modification request: ${prompt}

Please return the modified files in the same JSON format as before. Only include files that need to be changed or are new.`

      const response = await chatSession.sendMessage(modificationPrompt)
      const text = response.response.text()
      
      await logger.info('Gemini modification response received', {
        model: modelName,
        responseLength: text.length
      })

      // Parse the JSON response
      let parsedResponse
      let jsonContent = text.trim()
      
      const jsonMatch = jsonContent.match(/```(?:json)?\s*([\s\S]*?)\s*```/)
      if (jsonMatch) {
        jsonContent = jsonMatch[1].trim()
      }
      
      try {
        jsonContent = cleanJsonContent(jsonContent)
        parsedResponse = JSON.parse(jsonContent)
      } catch (parseError) {
        await logger.error('Failed to parse Gemini modification response', parseError as Error, {
          model: modelName,
          rawResponse: text.substring(0, 1000) + '...'
        })
        
        // Fallback: return existing files
        parsedResponse = {
          content: 'Project modified successfully (partial response)',
          files: currentFiles.map(file => ({
            path: file.path,
            content: file.content,
            type: file.type,
            size: file.content.length
          }))
        }
      }

      const aiResponse: AIResponse = {
        content: parsedResponse.content || 'Project modified successfully',
        files: sortFilesByPriority((parsedResponse.files || []).map((file: any) => ({
          path: file.path,
          content: file.content,
          type: getFileTypeFromPath(file.path),
          size: file.size || (file.content ? file.content.length : 0)
        }))),
        metadata: {
          model: modelName,
          tokens: 0,
          provider: 'gemini'
        }
      }

      const duration = Date.now() - startTime
      
      await logger.info('Gemini AI modification completed successfully', {
        model: modelName,
        duration,
        fileCount: aiResponse.files.length,
        tokens: aiResponse.metadata.tokens
      })

      return aiResponse
    })
  } catch (error) {
    const duration = Date.now() - startTime
    await logger.error('Gemini AI modification failed', error as Error, {
      model: GEMINI_MODEL,
      duration,
      promptLength: prompt.length,
      currentFileCount: currentFiles.length
    })
    
    throw new Error(`Gemini modification failed: ${error instanceof Error ? error.message : 'Unknown error'}`)
  }
}